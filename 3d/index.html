<!DOCTYPE html>
<html lang="zh-cn">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="./logo.png" rel="icon" type="image/x-ico">
    <title>Moren Three.js</title>
    <style>
        body { margin: 0; }  
        canvas { display: block; }  
        #controls { position: absolute; bottom: 30px; left: 30px; }  .ctrlButton{width:60px;height:60px;user-select:none;}
        #coordinates {  
            position: absolute;  
            top: 10px;  
            right: 10px;  
            color: white; /* æˆ–è€…ä½ æƒ³è¦çš„ä»»ä½•é¢œè‰² */  
            font-family: Arial, sans-serif;  
            background-color: rgba(0, 0, 0, 0.5); /* åŠé€æ˜èƒŒæ™¯ï¼Œä»¥ä¾¿åœ¨æ·±è‰²ç”»å¸ƒä¸Šçœ‹å¾—æ›´æ¸…æ¥š */  
            padding: 5px;  
            border-radius: 5px;  
            pointer-events: none;
        }
    </style>
</head>

<body>
    <div id="controls">
        <button id="forward" class="ctrlButton" style="position:absolute;bottom:60px;left:60px;">å‰è¿›</button>
        <button id="backward" class="ctrlButton" style="position:absolute;left:60px;">åé€€</button>
        <button id="left" class="ctrlButton">å·¦ç§»</button>
        <button id="right" class="ctrlButton" style="position:absolute;left:120px;">å³ç§»</button>
        <div style="position:fixed;bottom:120px;right:0px;">
            <button id="up" class="ctrlButton" style="position:absolute;right:10px;bottom:-40px;">ä¸Šç§»</button>
            <button id="down" class="ctrlButton" style="position:absolute;right:10px;bottom:-100px;">ä¸‹ç§»</button>
        </div>
    </div>
    <div id="coordinates"></div>
    <script src="./three.min.js" type="module"></script>
    <script src="./noise.js"></script>
    <script src="./ammo.js"></script>
    <script src="./jquery.js"></script>
    <script src="./Stats.min.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>
    <script type="module">
        import { OrbitControls } from './OrbitControls.js';
        import { Water } from './Water.js';
        import { Sky } from './Sky.js';
        import { OBJLoader } from './OBJLoader.js';  
        import { MTLLoader } from './MTLLoader.js';

        let scene, camera, renderer, planeMesh, cube, controls2, terrainMesh, water, duck, landbody, landTerrainMesh, duckBody, concreteMaterial, physicsWorld, dispatcher, stats;  
const MeshBodyToUpdate = [];
const MeshBodyToUpdate2 = [];
                let moveSpeed = 1; // å¯ä»¥è°ƒæ•´ç§»åŠ¨é€Ÿåº¦  
        
                let moveForwardInterval, moveBackwardInterval, moveLeftInterval, moveRightInterval, moveDownInterval, moveUpInterval; 
                
var gui = new dat.GUI();
gui.domElement.style.position = "relative";
gui.domElement.style.top = "50px";
var guiItem = gui.addFolder('three.jsé€‰é¡¹');

Ammo().then(function(){init();})
//-- ç‰©ç†ä¸–ç•Œå˜é‡
const gravityConstant = - 9.8;
function initPhysics() {
const collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();  
const dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration);  
const broadphase = new Ammo.btDbvtBroadphase();  
const solver = new Ammo.btSequentialImpulseConstraintSolver(); // åªéœ€è¦ä¸€ä¸ªæ±‚è§£å™¨  
  
// æ³¨æ„ï¼šbtDiscreteDynamicsWorld ä¸éœ€è¦ softBodySolver  
physicsWorld = new Ammo.btDiscreteDynamicsWorld(dispatcher, broadphase, solver, collisionConfiguration);  
  
// è®¾ç½®é‡åŠ›  
const gravityConstant = -9.8; // ä¾‹å¦‚ï¼Œåœ°çƒçš„é‡åŠ›åŠ é€Ÿåº¦  
const gravity = new Ammo.btVector3(0, gravityConstant, 0);  
physicsWorld.setGravity(gravity); // ä½¿ç”¨ setGravity æ–¹æ³•æ¥è®¾ç½®é‡åŠ›  
// åˆ›å»ºåœ°é¢
(function(){
// åˆ›å»ºå¹³é¢ä½ç½®å’Œæ—‹è½¬çš„å˜æ¢  
const planeTransform = new Ammo.btTransform();  
planeTransform.setIdentity();  
planeTransform.setOrigin(new Ammo.btVector3(0, -6, 0)); // è®¾ç½®å¹³é¢çš„ä½ç½®  
  
// åˆ›å»ºä¸€ä¸ªbtDefaultMotionStateå¯¹è±¡  
const planeMotionState = new Ammo.btDefaultMotionState(planeTransform);  
  
// åˆ›å»ºä¸€ä¸ªç¢°æ’å½¢çŠ¶ï¼Œè¿™é‡Œæˆ‘ä»¬ä½¿ç”¨btBoxShapeæ¥è¡¨ç¤ºä¸€ä¸ªçŸ©å½¢å¹³é¢  
const planeHalfExtents = new Ammo.btVector3(800, 0.1, 800); // åŠå°ºå¯¸  
const planeShape = new Ammo.btBoxShape(planeHalfExtents);  
  
// è®¡ç®—å±€éƒ¨æƒ¯æ€§ï¼ˆå¯¹äºé™æ€ç‰©ä½“ï¼Œè¿™é€šå¸¸ä¸é‡è¦ï¼Œä½†æŸäº›å®ç°å¯èƒ½è¦æ±‚è¿™æ ·åšï¼‰  
const localInertia = new Ammo.btVector3(0, 0, 0);  
  
// åˆ›å»ºä¸€ä¸ªåˆšä½“æ„é€ ä¿¡æ¯ï¼Œè´¨é‡è®¾ç½®ä¸º0è¡¨ç¤ºå®ƒæ˜¯ä¸€ä¸ªé™æ€ç‰©ä½“  
const rbInfo = new Ammo.btRigidBodyConstructionInfo(0, planeMotionState, planeShape, localInertia);  
  
// åˆ›å»ºä¸€ä¸ªåˆšä½“å¹¶æ·»åŠ åˆ°ç‰©ç†ä¸–ç•Œä¸­  
const planeBody = new Ammo.btRigidBody(rbInfo);  
planeBody.setFriction(0.9);
physicsWorld.addRigidBody(planeBody);  
 })()

createMeshAndRigidBody();
}

function createMeshAndRigidBody(position = {x: 0, y: 10, z:0}) {  
// Ammo.js ç‰©ç†çƒä½“å‚æ•°  
const mass = 1;  
const radius = 1.5;  
const startTransform = new Ammo.btTransform();  
startTransform.setIdentity();  
startTransform.setOrigin(new Ammo.btVector3(position.x, position.y, position.z)); // è®¾ç½®åˆå§‹ä½ç½®  

// åˆ›å»ºç¢°æ’å½¢çŠ¶  
const collisionShape = new Ammo.btSphereShape(radius);  
  
// åˆ›å»ºåˆšä½“æ„é€ ä¿¡æ¯  
const localInertia = new Ammo.btVector3(0, 0, 0);  
collisionShape.calculateLocalInertia(mass, localInertia);  
  
// åˆ›å»ºåˆšä½“  
const motionState = new Ammo.btDefaultMotionState(startTransform);  
const rbInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, collisionShape, localInertia);  
const body = new Ammo.btRigidBody(rbInfo);  
  
// æ·»åŠ åˆ°ç‰©ç†ä¸–ç•Œ  
physicsWorld.addRigidBody(body);


// three.js åœºæ™¯ã€ç›¸æœºå’Œæ¸²æŸ“å™¨å·²è®¾ç½®...  
  
// åˆ›å»ºçƒä½“å‡ ä½•ä½“å’Œæè´¨  
const textureLoader = new THREE.TextureLoader();  
const texture = textureLoader.load('./good.png'); // æ›¿æ¢ä¸ºä½ çš„å›¾ç‰‡è·¯å¾„  
const geometry = new THREE.SphereGeometry(radius, 48, 48); // åŠå¾„ã€å®½åº¦åˆ†æ®µã€é«˜åº¦åˆ†æ®µ  
// åˆ›å»ºæè´¨  
const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide  });  
  
// åˆ›å»ºthree.jsçƒä½“æ¨¡å‹  
const sphereMesh = new THREE.Mesh(geometry, material);  
  
// æ·»åŠ åˆ°åœºæ™¯ä¸­  
scene.add(sphereMesh);
  
  // å°†ç½‘æ ¼å’Œåˆšä½“æ·»åŠ åˆ°æ›´æ–°æ•°ç»„ä¸­  
  MeshBodyToUpdate2.push({ mesh: sphereMesh, body: body });  
}  

                function init() {  

                    // åˆ›å»ºåœºæ™¯  
                    scene = new THREE.Scene(); 
               
                  var axes = new THREE.AxesHelper( 20 );
                    scene.add(axes);
                    // åˆ›å»ºç›¸æœº  
                    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);  
                    camera.position.set(0, 0, 5);  
                 
                    // åˆ›å»ºæ¸²æŸ“å™¨  
                    renderer = new THREE.WebGLRenderer({antialias: true});  
                    renderer.setSize(window.innerWidth, window.innerHeight);  
                    document.body.appendChild(renderer.domElement);  
                      
initPhysics();

//åˆ›å»ºstatså¯¹è±¡
stats = new Stats();
//stats.domElement:webé¡µé¢ä¸Šè¾“å‡ºè®¡ç®—ç»“æœ,ä¸€ä¸ªdivå…ƒç´ ï¼Œ
document.body.appendChild(stats.domElement);

                    // åŠ è½½çº¹ç†  
                    const textureLoader = new THREE.TextureLoader();  
                    const texture = textureLoader.load('./good.png'); // æ›¿æ¢ä¸ºä½ çš„å›¾ç‰‡è·¯å¾„  
                      
                    // åˆ›å»ºå¹³é¢å‡ ä½•ä½“  
                    const geometry = new THREE.PlaneGeometry(10, 10);  
                      
                    // åˆ›å»ºæè´¨  
                    const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide  });  
                      
                    // åˆ›å»ºå¹³é¢ç½‘æ ¼  
                    planeMesh = new THREE.Mesh(geometry, material);  
                    planeMesh.position.set(0, 5, 0);
                    scene.add(planeMesh);  

function aduck() {
    const mtlLoader = new MTLLoader();  
    const objLoader = new OBJLoader();

    mtlLoader.load('./bird/12248_Bird_v1_L2.mtl', function(materials) {  
        objLoader.setMaterials(materials); // è®¾ç½®OBJLoaderä½¿ç”¨çš„æè´¨  

        const scaleFactor = 0.05;
        objLoader.load('./bird/12248_Bird_v1_L2.obj', function(duckModel) {  
            duck = duckModel;  
            duck.scale.set(scaleFactor, scaleFactor, scaleFactor);  
            duck.position.set(1, 10, 1); // åˆå§‹ä½ç½®  
            duck.rotation.set(1.5 * Math.PI, 0, Math.PI); // åˆå§‹æ—‹è½¬  

            // åˆ›å»ºé¸­å­æ¨¡å‹çš„å‡¸åŒ…å½¢çŠ¶
            const vertices = [];
            duck.traverse(function(child) {
                if (child instanceof THREE.Mesh) {
                    const geometry = child.geometry;
                    const positions = geometry.attributes.position;
for (let i = 0; i < positions.count; i++) {
    // å¦‚æœ i æ˜¯åŒæ•°ï¼Œåˆ™è·³è¿‡å½“å‰å¾ªç¯
    if (i % 10 === 0) {
        continue;
    }

    const vertex = new Ammo.btVector3(
        positions.getX(i) * scaleFactor,
        positions.getY(i) * scaleFactor,
        positions.getZ(i) * scaleFactor
    );
    vertices.push(vertex);
}
                }
            });
            const shape = new Ammo.btConvexHullShape();
            vertices.forEach(function(vertex) {
                shape.addPoint(vertex);
            });

            // åˆ›å»ºåˆšä½“
            const transform = new Ammo.btTransform();
            transform.setIdentity();
            transform.setOrigin(new Ammo.btVector3(1, 10, 1)); // åˆå§‹ä½ç½®
            const motionState = new Ammo.btDefaultMotionState(transform);
            const localInertia = new Ammo.btVector3(0, 0, 0);
            shape.calculateLocalInertia(5, localInertia); // è´¨é‡ä¸º1
            const rbInfo = new Ammo.btRigidBodyConstructionInfo(1, motionState, shape, localInertia);
            duckBody = new Ammo.btRigidBody(rbInfo);
            duckBody.setFriction(1);
            duckBody.setRestitution(0);

            // å°†åˆšä½“æ·»åŠ åˆ°ç‰©ç†ä¸–ç•Œä¸­
            physicsWorld.addRigidBody(duckBody);

            // å°†æ¨¡å‹æ·»åŠ åˆ°Three.jsåœºæ™¯  
            scene.add(duck); 

            MeshBodyToUpdate2.push({ mesh: duck, body: duckBody }); 
        }, undefined, function(error) {  
            console.error(error);  
        });
    });
}


function generateTerrain() { 
let indices = []; // å­˜å‚¨ç´¢å¼•  
const simplexNoise = new SimplexNoise();  
  
// è®¾å®šåœ°å½¢çš„å°ºå¯¸å’Œå‚æ•°  
const width = 200;  
const depth = 200;  
const octaves = 3; // å™ªå£°å±‚æ•°  
const persistence = 0.5; // æ¯å±‚å™ªå£°çš„è¡°å‡ç‡  
const lacunarity = 2.0; // æ¯å±‚å™ªå£°é¢‘ç‡çš„ç¼©æ”¾æ¯”ä¾‹  
const baseFrequency = 0.01; // åŸºç¡€å™ªå£°é¢‘ç‡  
const amplitude = 8; // å™ªå£°å€¼çš„æŒ¯å¹…  
const scale = 50; // å™ªå£°å€¼çš„ç¼©æ”¾å› å­  
const smoothing = 0.03; // å¹³æ»‘å› å­  
const elementSize = 4;  
let vertices = [];  
  
let totalAmplitude = 0;  
for (let i = 0; i < octaves; i++) {  
    totalAmplitude += Math.pow(persistence, i);  
}  
  
for (let z = 0; z < depth; z++) {  
    for (let x = 0; x < width; x++) {  
        let noiseValue = 0;  
        let currentFrequency = baseFrequency;  
        let currentAmplitude = amplitude;  
  
        for (let i = 0; i < octaves; i++) {  
            noiseValue += simplexNoise.noise2D(x * currentFrequency, z * currentFrequency) * currentAmplitude;  
            currentFrequency *= lacunarity;  
            currentAmplitude *= persistence;  
        }  
  
        // å½’ä¸€åŒ–å™ªå£°å€¼  
        noiseValue /= totalAmplitude;  
  
        // åº”ç”¨å¹³æ»‘å¤„ç†  
        const smoothNoiseValue = noiseValue * (1 - smoothing) + (simplexNoise.noise2D(x * currentFrequency * 2, z * currentFrequency * 2) * smoothing);  
  
        // æ ¹æ®å™ªå£°è®¡ç®—é«˜åº¦ï¼Œå¹¶åŠ å…¥ä¸€äº›åç§»å’Œç¼©æ”¾  
        const y = (smoothNoiseValue + 0.5) * amplitude * 2;  
  
        vertices.push(x * elementSize, y, z * elementSize);  

        // åˆ¤æ–­æ˜¯å¦åœ¨éšæœºä½ç½®ç”Ÿæˆæ ‘
        if (Math.random() < 0.001 && y > 10) { // è¿™é‡Œçš„0.1è¡¨ç¤ºæ ‘ç”Ÿæˆçš„æ¦‚ç‡ï¼Œä½ å¯ä»¥æ ¹æ®éœ€è¦è°ƒæ•´
            trees((x - width / 2) * elementSize, y, (z - depth / 2) * elementSize);console.log(1);
        }
    }  
}
  

// åˆ›å»ºç´¢å¼•ä»¥å®šä¹‰åœ°å½¢ç½‘æ ¼çš„ä¸‰è§’å½¢  
for (let x = 0; x < width - 1; x++) {  
    for (let z = 0; z < depth - 1; z++) {  
        const a = x * depth + z;  
        const b = x * depth + z + 1;  
        const c = (x + 1) * depth + z;  
        const d = (x + 1) * depth + z + 1;  
  
        // ä¸¤ä¸ªä¸‰è§’å½¢å…±äº«ä¸¤ä¸ªé¡¶ç‚¹  
        indices.push(a, b, d);  
        indices.push(a, d, c);  
    }  
}  

// åˆ›å»ºBufferGeometry  
const geometry = new THREE.BufferGeometry();  
  
// è®¾ç½®é¡¶ç‚¹ä½ç½®å±æ€§  
geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));  
  
// è®¾ç½®ç´¢å¼•  
geometry.setIndex(new THREE.BufferAttribute(new Uint32Array(indices), 1));  
  
// å¦‚æœéœ€è¦ï¼Œè®¡ç®—æ³•çº¿  
geometry.computeVertexNormals();  
  

var testObj = {
    wireframe: false,
    createBall: function() {
        createMeshAndRigidBody({x: camera.position.x, y: camera.position.y, z: camera.position.z});
    }
};

var controller = guiItem.add(testObj, "wireframe", ['false', 'true']);

// ç›‘å¬ wireframe å±æ€§çš„å˜åŒ–
controller.onChange(function(value) {
    // å°†å­—ç¬¦ä¸²å€¼è½¬æ¢ä¸ºå¸ƒå°”å€¼
    var wireframeValue = (value === 'true');

    // æ›´æ–° landTerrainMesh.material.wireframe
    landTerrainMesh.material.wireframe = wireframeValue;
});

guiItem.add(testObj, 'createBall').name('Create Ball');

// åˆ›å»ºæè´¨ï¼Œå¹¶å¯ç”¨é¡¶ç‚¹é¢œè‰²  
const material = new THREE.MeshPhongMaterial({  
    vertexColors: THREE.VertexColors, // ä½¿ç”¨é¡¶ç‚¹é¢œè‰²æ¸²æŸ“  
    side: THREE.DoubleSide,
    wireframe: testObj.wireframe
});  

// åˆ›å»ºåœ°å½¢ç½‘æ ¼  
landTerrainMesh = new THREE.Mesh(geometry, material);  

// å°†åœ°å½¢ç½‘æ ¼æ·»åŠ åˆ°åœºæ™¯ä¸­
scene.add(landTerrainMesh);




// åˆ›å»ºåœ°å½¢ç‰©ç†å½¢çŠ¶
function createTerrainPhysics(vertices, indices) {
    // åˆ›å»ºä¸‰è§’å½¢ç½‘æ ¼å½¢çŠ¶
    const triangleMesh = new Ammo.btTriangleMesh();

    // æ·»åŠ ä¸‰è§’å½¢
    for (let i = 0; i < indices.length; i += 3) {
        const vertex1 = new Ammo.btVector3(vertices[indices[i] * 3], vertices[indices[i] * 3 + 1], vertices[indices[i] * 3 + 2]);
        const vertex2 = new Ammo.btVector3(vertices[indices[i + 1] * 3], vertices[indices[i + 1] * 3 + 1], vertices[indices[i + 1] * 3 + 2]);
        const vertex3 = new Ammo.btVector3(vertices[indices[i + 2] * 3], vertices[indices[i + 2] * 3 + 1], vertices[indices[i + 2] * 3 + 2]);
        triangleMesh.addTriangle(vertex1, vertex2, vertex3, true);
    }

    // åˆ›å»ºåœ°å½¢ç‰©ç†å½¢çŠ¶
    const terrainShape = new Ammo.btBvhTriangleMeshShape(triangleMesh, true, true);

    return terrainShape;
}

// åœ¨åœºæ™¯ä¸­åˆ›å»ºåœ°å½¢
function createTerrain(scene, terrainShape, position) {
    // åˆ›å»ºåœ°å½¢åˆšä½“
    const groundTransform = new Ammo.btTransform();
    groundTransform.setIdentity();
    groundTransform.setOrigin(new Ammo.btVector3(position.x, position.y, position.z));
    const groundMass = 0;
    const groundLocalInertia = new Ammo.btVector3(0, 0, 0);
    const groundMotionState = new Ammo.btDefaultMotionState(groundTransform);
    const groundBodyInfo = new Ammo.btRigidBodyConstructionInfo(groundMass, groundMotionState, terrainShape, groundLocalInertia);
    const groundBody = new Ammo.btRigidBody(groundBodyInfo);
    groundBody.setFriction(0.9);
    // æ·»åŠ åœ°å½¢åˆ°åœºæ™¯
    physicsWorld.addRigidBody(groundBody);
    MeshBodyToUpdate2.push({ mesh: landTerrainMesh, body: groundBody });  
}

// ä½¿ç”¨ç¤ºä¾‹
let terrainShape = createTerrainPhysics(vertices, indices);
createTerrain(scene, terrainShape, { x: -width * elementSize / 2, y: 0, z: -depth * elementSize / 2 }); // è®¾ç½®åœ°å½¢ä½ç½®

terrainShape = null;
vertices = null;
indices = null;

aduck();
}  
  
generateTerrain();

// è®¾ç½®æ¸²æŸ“å™¨çš„é˜´å½±æ˜ å°„å±æ€§  
renderer.shadowMap.enabled = true; // å¯ç”¨é˜´å½±æ˜ å°„  
renderer.shadowMap.type = THREE.PCFSoftShadowMap; // ä½¿ç”¨æŸ”å’Œé˜´å½±ï¼Œæ ¹æ®éœ€è¦è°ƒæ•´  

var directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);  
directionalLight.position.set(10, 10, 10); // è®¾ç½®å…‰æºä½ç½®  
directionalLight.castShadow = true; // å¯ç”¨é˜´å½±æŠ•å°„  
scene.add(directionalLight);  

var directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);  
directionalLight.position.set(-10, 10, -10); // è®¾ç½®å…‰æºä½ç½®  
directionalLight.castShadow = true; // å¯ç”¨é˜´å½±æŠ•å°„  
scene.add(directionalLight);  

var directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);  
directionalLight.position.set(0, -20, 0); // è®¾ç½®å…‰æºä½ç½®  
directionalLight.castShadow = true; // å¯ç”¨é˜´å½±æŠ•å°„  
scene.add(directionalLight);  

function initSkyWater(){
const sky = new Sky();
sky.scale.setScalar(100000);
scene.add(sky);
const skyUniforms = sky.material.uniforms;
skyUniforms['turbidity'].value = 10;
skyUniforms['rayleigh'].value = 2;
skyUniforms['mieCoefficient'].value = 0.005;
skyUniforms['mieDirectionalG'].value = 0.8;
// å¤ªé˜³
const sun = new THREE.Vector3();
const pmremGenerator = new THREE.PMREMGenerator(renderer);
const phi = THREE.MathUtils.degToRad(88);
const theta = THREE.MathUtils.degToRad(180);
sun.setFromSphericalCoords(1, phi, theta);
sky.material.uniforms['sunPosition'].value.copy(sun);
scene.environment = pmremGenerator.fromScene(sky).texture;

      let waterGeometry = new THREE.PlaneGeometry( 1200, 1200 );
      water = new Water(
        waterGeometry,
        {
          textureWidth: 1200,
          textureHeight: 1200,
          waterNormals: new THREE.TextureLoader().load('./waternormals.jpg', ( texture )=> {
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
          } ),
          alpha: 1.0,
          sunColor: 0xffffff,
          waterColor: 0x001e0f,
          distortionScale: 1,
          side: THREE.DoubleSide
        }
      );
      water.rotation.x = - Math.PI / 2;
      water.position.y = -5;
      scene.add( water );
  }
initSkyWater();

var treeModel; // ä¿å­˜åŠ è½½çš„æ¨¡å‹

function trees(x = 5, y = 5, z = 5){
    // å¦‚æœæ¨¡å‹å·²ç»åŠ è½½ï¼Œåˆ™ç›´æ¥ä½¿ç”¨
    if (treeModel) {
        const treeClone = treeModel.clone();
        treeClone.scale.set(2, 2, 2);
        treeClone.position.set(x, y, z);
        scene.add(treeClone); // å°†æ¨¡å‹æ·»åŠ åˆ°åœºæ™¯ä¸­  
    } else {
        const mtlLoader = new MTLLoader();  
        const objLoader = new OBJLoader();
        
        mtlLoader.load('./tree/Tree.mtl', function(materials) {  
            // materials æ˜¯ä¸€ä¸ªåŒ…å«æ‰€æœ‰æè´¨çš„Mapå¯¹è±¡  
            // ç°åœ¨å¯ä»¥ä½¿ç”¨è¿™äº›æè´¨æ¥åŠ è½½.objæ–‡ä»¶  
            objLoader.setMaterials(materials); // è®¾ç½®OBJLoaderä½¿ç”¨çš„æè´¨  
            
            objLoader.load('./tree/Tree.obj', function(tree) {  
                treeModel = tree;
                const treeClone = tree.clone();
                treeClone.scale.set(2, 2, 2);
                treeClone.position.set(x, y, z);
                scene.add(treeClone); // å°†æ¨¡å‹æ·»åŠ åˆ°åœºæ™¯ä¸­  
            }, undefined, function(error) {  
                console.error(error);  
            });
        });
    }
}



function cloud(){
// åŠ è½½çº¹ç†  
const textureLoader = new THREE.TextureLoader();  
const texture = textureLoader.load('cloud.png'); // æ›¿æ¢ä¸ºä½ çš„çº¹ç†å›¾ç‰‡è·¯å¾„  
texture.transparent = true; // å¯ç”¨é€æ˜  

// åˆ›å»ºåŒé¢æ¸²æŸ“çš„æè´¨  
const material = new THREE.MeshBasicMaterial({  
    map: texture,  
    transparent: true, // å¯ç”¨é€æ˜  
    side: THREE.DoubleSide, // åŒé¢æ¸²æŸ“  
    logarithmicDepthBuffer:true
});  
  
// æ·»åŠ åå¼ å›¾ç‰‡åˆ°éšæœºä½ç½®  
const numImages = 20;  
for (let i = 0; i < numImages; i++) {  
// åˆ›å»ºå¹³é¢ç½‘æ ¼  
const planeGeometry = new THREE.PlaneGeometry(Math.random() * 200, Math.random() * 180); // ä½ å¯ä»¥è°ƒæ•´å¹³é¢çš„å¤§å°  
    const plane = new THREE.Mesh(planeGeometry, material);  
  
    // ç”Ÿæˆéšæœºä½ç½®  
    const randomX = Math.random() * 1000 - 500; // å‡è®¾åœºæ™¯åœ¨-50åˆ°50çš„xèŒƒå›´å†…  
    const randomY = Math.random() * (200 - 40) + 100; // å‡è®¾åœºæ™¯åœ¨40åˆ°60çš„yèŒƒå›´å†…  
    const randomZ = Math.random() * 1000 - 500; // å‡è®¾åœºæ™¯åœ¨-50åˆ°50çš„zèŒƒå›´å†…  
    plane.position.set(randomX, randomY, randomZ);  

    // å¦‚æœéœ€è¦ï¼Œå¯ä»¥æ—‹è½¬ç½‘æ ¼ä»¥è·å¾—ä¸åŒçš„è§’åº¦  
    plane.rotation.y = Math.random();  
    // æ·»åŠ åˆ°åœºæ™¯  
    scene.add(plane);  
} 
}
cloud();

                            let geometry2 = new THREE.BoxGeometry(0.2, 0.2, 0.2);
        const material2 = new THREE.MeshBasicMaterial({ color: 0xff0000, map: texture}); // ä½¿ç”¨æœ€åŸºç¡€çš„æè´¨ï¼Œé¢œè‰²è®¾ä¸ºçº¢è‰²
        cube = new THREE.Mesh(geometry2, material2);
        cube.position.set(2, 0, 0);
        scene.add(cube);
        const tick = () => {
          cube.rotation.y += 0.01;
          renderer.render(scene, camera);
          window.requestAnimationFrame(tick);
        };

        controls2 = new OrbitControls(camera, renderer.domElement);
controls2.enableZoom = true; // å…è®¸ç¼©æ”¾  
controls2.zoomSpeed = 10;
controls2.enableRotate = true; // å…è®¸æ—‹è½¬  
controls2.enablePan = false; // å…è®¸å¹³ç§»  

        BoxFollow();

                  
        let keys = {  
          w: false,  
          a: false,  
          s: false,  
          d: false,  
          Shift: false,  
          ' ': false  
        };  
          
        document.addEventListener('keydown', function(event) {  
          switch (event.key) {  
            case 'w':  
              if (!keys.w) {  
                keys.w = true;  
                startMovingForward();  
              }  
              break; // æ·»åŠ breakè¯­å¥  
            case 'a':  
              if (!keys.a) {  
                keys.a = true;  
                startMovingLeft();  
              }  
              break; // æ·»åŠ breakè¯­å¥  
            case 's':  
              if (!keys.s) {  
                keys.s = true;  
                startMovingBackward();  
              }  
              break; // æ·»åŠ breakè¯­å¥  
            case 'd':  
              if (!keys.d) {  
                keys.d = true;  
                startMovingRight();  
              }  
              break; // æ·»åŠ breakè¯­å¥  
            case 'Shift':  
              if (!keys.Shift) {  
                keys.Shift = true;  
                startMovingDown();  
              }  
              break; // æ·»åŠ breakè¯­å¥  
            case ' ':  
              if (!keys[' ']) {  
                keys[' '] = true;  
                startMovingUp();  
              }  
              break; // æ·»åŠ breakè¯­å¥  
          }  
        });  
          
        document.addEventListener('keyup', function(event) {  
          switch (event.key) {  
            case 'w':  
              if (keys.w) {  
                keys.w = false;  
                stopMovingForward(); // å‡è®¾æœ‰ä¸€ä¸ªä¸startMovingForwardå¯¹åº”çš„stopå‡½æ•°  
              }  
              break; // æ·»åŠ breakè¯­å¥  
            case 'a':  
              if (keys.a) {  
                keys.a = false;  
                stopMovingLeft(); // å‡è®¾æœ‰ä¸€ä¸ªä¸startMovingLeftå¯¹åº”çš„stopå‡½æ•°  
              }  
              break; // æ·»åŠ breakè¯­å¥  
            case 's':  
              if (keys.s) {  
                keys.s = false;  
                stopMovingBackward(); // å‡è®¾æœ‰ä¸€ä¸ªä¸startMovingBackwardå¯¹åº”çš„stopå‡½æ•°  
              }  
              break; // æ·»åŠ breakè¯­å¥  
            case 'd':  
              if (keys.d) {  
                keys.d = false;  
                stopMovingRight(); // å‡è®¾æœ‰ä¸€ä¸ªä¸startMovingRightå¯¹åº”çš„stopå‡½æ•°  
              }  
              break; // æ·»åŠ breakè¯­å¥  
            case 'Shift':  
              if (keys.Shift) {  
                keys.Shift = false;  
                stopMovingDown(); // å‡è®¾æœ‰ä¸€ä¸ªä¸startMovingDownå¯¹åº”çš„stopå‡½æ•°  
              }  
              break; // æ·»åŠ breakè¯­å¥  
            case ' ':  
              if (keys[' ']) {  
                keys[' '] = false;  
                stopMovingUp(); // å‡è®¾æœ‰ä¸€ä¸ªä¸startMovingUpå¯¹åº”çš„stopå‡½æ•°  
              }  
              break; // æ·»åŠ breakè¯­å¥  
          }  
        });


                    // ç»‘å®šæŒ‰é’®äº‹ä»¶  
                    document.getElementById('forward').addEventListener('mousedown', startMovingForward);  
                    document.getElementById('forward').addEventListener('mouseup', stopMovingForward);  
                    document.getElementById('forward').addEventListener('mouseleave', stopMovingForward); // å¦‚æœé¼ æ ‡ç¦»å¼€æŒ‰é’®ä¹Ÿåœæ­¢ç§»åŠ¨  
                  
                    document.getElementById('backward').addEventListener('mousedown', startMovingBackward);  
                    document.getElementById('backward').addEventListener('mouseup', stopMovingBackward);  
                    document.getElementById('backward').addEventListener('mouseleave', stopMovingBackward);  
                  
                    document.getElementById('left').addEventListener('mousedown', startMovingLeft);  
                    document.getElementById('left').addEventListener('mouseup', stopMovingLeft);  
                    document.getElementById('left').addEventListener('mouseleave', stopMovingLeft);  
                  
                    document.getElementById('right').addEventListener('mousedown', startMovingRight);  
                    document.getElementById('right').addEventListener('mouseup', stopMovingRight);  
                    document.getElementById('right').addEventListener('mouseleave', stopMovingRight); 
        
                    document.getElementById('up').addEventListener('mousedown', startMovingUp);  
                    document.getElementById('up').addEventListener('mouseup', stopMovingUp);  
                    document.getElementById('up').addEventListener('mouseleave', stopMovingUp); 
        
                    document.getElementById('down').addEventListener('mousedown', startMovingDown);  
                    document.getElementById('down').addEventListener('mouseup', stopMovingDown);  
                    document.getElementById('down').addEventListener('mouseleave', stopMovingDown); 

                  
                      // ä¸ºå‰è¿›æŒ‰é’®æ·»åŠ è§¦æ‘¸äº‹ä»¶  
                    var forwardButton = document.getElementById('forward');  
                    forwardButton.addEventListener('touchstart', startMovingForward, { passive: true });  
                    forwardButton.addEventListener('touchend', stopMovingForward);  
                    forwardButton.addEventListener('touchcancel', stopMovingForward); // å½“è§¦æ‘¸è¢«å–æ¶ˆæ—¶åœæ­¢ç§»åŠ¨  
                  
                    // ä¸ºåé€€æŒ‰é’®æ·»åŠ è§¦æ‘¸äº‹ä»¶  
                    var backwardButton = document.getElementById('backward');  
                    backwardButton.addEventListener('touchstart', startMovingBackward, { passive: true });  
                    backwardButton.addEventListener('touchend', stopMovingBackward);  
                    backwardButton.addEventListener('touchcancel', stopMovingBackward);  
                  
                    // ä¸ºå·¦ç§»æŒ‰é’®æ·»åŠ è§¦æ‘¸äº‹ä»¶  
                    var leftButton = document.getElementById('left');  
                    leftButton.addEventListener('touchstart', startMovingLeft, { passive: true });  
                    leftButton.addEventListener('touchend', stopMovingLeft);  
                    leftButton.addEventListener('touchcancel', stopMovingLeft);  
                  
                    // ä¸ºå³ç§»æŒ‰é’®æ·»åŠ è§¦æ‘¸äº‹ä»¶  
                    var rightButton = document.getElementById('right');  
                    rightButton.addEventListener('touchstart', startMovingRight, { passive: true });  
                    rightButton.addEventListener('touchend', stopMovingRight);  
                    rightButton.addEventListener('touchcancel', stopMovingRight);  
                  
                    // ä¸ºä¸Šç§»æŒ‰é’®æ·»åŠ è§¦æ‘¸äº‹ä»¶  
                    var upButton = document.getElementById('up');  
                    upButton.addEventListener('touchstart', startMovingUp, { passive: true });  
                    upButton.addEventListener('touchend', stopMovingUp);  
                    upButton.addEventListener('touchcancel', stopMovingUp); 
        
                    // ä¸ºä¸‹ç§»æŒ‰é’®æ·»åŠ è§¦æ‘¸äº‹ä»¶  
                    var downButton = document.getElementById('down');  
                    downButton.addEventListener('touchstart', startMovingDown, { passive: true });  
                    downButton.addEventListener('touchend', stopMovingDown);  
                    downButton.addEventListener('touchcancel', stopMovingDown); 
     
let oldElapsedTime = 0
var clock = new THREE.Clock();
// æ¸²æŸ“å¾ªç¯  
function animate() { 
    stats.update();
    physicsWorld.stepSimulation( clock.getDelta() , 10 );

    // å‡è®¾MeshBodyToUpdate2æ˜¯ä¸€ä¸ªåŒ…å«Three.js Meshå’Œammo.jsåˆšä½“å¯¹åº”å…³ç³»çš„æ•°ç»„  
    for (const object of MeshBodyToUpdate2) {  
      const pos = object.body.getWorldTransform().getOrigin(); 
      // å°†ä½ç½®å’Œæ—‹è½¬ä¿¡æ¯åº”ç”¨åˆ°Three.jsçš„Meshä¸Š  
      object.mesh.position.set(pos.x(), pos.y(), pos.z());

      const ammoTransform = object.body.getWorldTransform().getRotation(); // è¿”å›ä¸€ä¸ªåŒ…å«ä½ç½®ã€æ—‹è½¬å’Œç¼©æ”¾çš„å¯¹è±¡  
      // æ›´æ–°three.js meshçš„æ—‹è½¬  
      object.mesh.quaternion.set(
          ammoTransform.x(),  
          ammoTransform.y(),  
          ammoTransform.z(),  
          ammoTransform.w() // æ³¨æ„wæ˜¯æœ€åä¸€ä¸ªåˆ†é‡ï¼Œä»£è¡¨å®éƒ¨  
      );
    }

    const elapsedTime = clock.getElapsedTime()
    const deltaTime = elapsedTime - oldElapsedTime
    oldElapsedTime = elapsedTime
    water.material.uniforms[ 'time' ].value += 1.0 / 120.0;
    controls2.update(clock.getDelta());
    BoxFollow();

    if (duck) {
            // æ›´æ–°åæ ‡æ˜¾ç¤º  
            const x = camera.position.x.toFixed(2);  
            const y = camera.position.y.toFixed(2);  
            const z = camera.position.z.toFixed(2);  
            const x2 = duck.position.x.toFixed(2);  
            const y2 = duck.position.y.toFixed(2);  
            const z2 = duck.position.z.toFixed(2);  
            document.getElementById('coordinates').textContent = `X: ${x} | ${x2}, Y: ${y} | ${y2}, Z: ${z} | ${z2}`; 
            if (Math.abs(x2) > 600 || Math.abs(y2) > 600 || Math.abs(z2) > 600 || Math.abs(x) > 2000 || Math.abs(y) > 2000 || Math.abs(z) > 2000) {
                duckBody.getWorldTransform().setOrigin(0, 10, 0);
                camera.position.set(0, 0, 5);
                stopMove();
                document.getElementById('coordinates').textContent = `X: ${x} | ${x2}, Y: ${y} | ${y2}, Z: ${z} | ${z2}`; 
            } else if (Math.abs(x2) > 500 || Math.abs(y2) > 500 || Math.abs(z2) > 500 || Math.abs(x) > 1800 || Math.abs(y) > 1800 || Math.abs(z) > 1800) {
                document.getElementById('coordinates').textContent = `X: ${x} | ${x2}, Y: ${y} | ${y2}, Z: ${z} | ${z2} ğŸ˜¡ğŸ˜¡ğŸ˜¡ğŸ˜¡çˆ¬å›å»ğŸ˜¡ğŸ˜¡ğŸ˜¡ğŸ˜¡`; 
            } else {
                document.getElementById('coordinates').textContent = `X: ${x} | ${x2}, Y: ${y} | ${y2}, Z: ${z} | ${z2}`; 
            }
    }

    requestAnimationFrame(animate);  
    renderer.render(scene, camera);  
}  
                    animate();  
                      
                    // çª—å£å¤§å°æ”¹å˜æ—¶æ›´æ–°ç›¸æœºå’Œæ¸²æŸ“å™¨  
                    window.addEventListener('resize', onWindowResize, false);  
                }  
                
function stopMove() {
                stopMovingForward();
                stopMovingBackward();
                stopMovingLeft();
                stopMovingRight();
                stopMovingDown();
                stopMovingUp();
}

                function moveCamera(x, y, z) {  
                    camera.position.x += x;  
                    camera.position.y += y;  
                    camera.position.z += z;  
                }  
                  
                function onWindowResize() {  
                    camera.aspect = window.innerWidth / window.innerHeight;  
                    camera.updateProjectionMatrix();  
                    renderer.setSize(window.innerWidth, window.innerHeight);  
                }  

        function BoxFollow() {
            const dir = new THREE.Vector3();  
            camera.getWorldDirection(dir);  
            const newPosition = camera.position.clone().add(dir.clone().multiplyScalar(0.4)); 
            newPosition.y -= 0.25; 
            // è®¾ç½®cubeçš„ä½ç½®ä¸ºè®¡ç®—å‡ºçš„æ–°ä½ç½®  
            if (duckBody) {
              // è·å–æ‘„åƒæœºçš„æ—‹è½¬å››å…ƒæ•°  
              var cameraQuaternion = camera.quaternion;  
  
              // åˆ›å»ºä¸€ä¸ªæ–°çš„å››å…ƒæ•°ï¼Œç”¨äºä»…æå–æ‘„åƒæœºçš„ä¿¯ä»°å’Œåèˆªæ—‹è½¬  
              // è¿™å¯ä»¥é€šè¿‡å°†æ‘„åƒæœºçš„å››å…ƒæ•°è½¬æ¢ä¸ºæ¬§æ‹‰è§’ï¼Œç„¶åé‡æ–°è®¾ç½®æ»šåŠ¨ï¼ˆrollï¼‰ä¸º0æ¥å®ç°  
              var euler = new THREE.Euler().setFromQuaternion(cameraQuaternion, 'YXZ'); // æ³¨æ„é¡ºåºå¯èƒ½æ˜¯'XYZ', 'YZX'ç­‰ï¼Œå–å†³äºä½ çš„éœ€æ±‚  
              euler.x = 1.5 * Math.PI; // è®¾ç½®æ»šåŠ¨ä¸º0ï¼Œå› ä¸ºæˆ‘ä»¬ä¸å…³å¿ƒå®ƒåœ¨é¡¶éƒ¨æ–¹å‘ä¸Šçš„å½±å“  
              euler.z = Math.PI;
              var duckQuaternion = new THREE.Quaternion().setFromEuler(euler);  
  
              // å°†æå–å‡ºçš„æ—‹è½¬åº”ç”¨åˆ°duckä¸Š  
              duck.quaternion.copy(duckQuaternion);  
            }
            newPosition.y += 0.25;  
            controls2.target = newPosition; 
        }

                function startMovingForward() {  
if (moveForwardInterval) {clearInterval(moveForwardInterval);}
                    moveForwardInterval = setInterval(function(){const dir = new THREE.Vector3();
        // è·å–ç›¸æœºçš„è§†çº¿æ–¹å‘
        camera.getWorldDirection(dir);
        // diså‘é‡è¡¨ç¤ºç›¸æœºæ²¿ç€ç›¸æœºè§†çº¿æ–¹å‘å¹³ç§»çš„ä½ç§»é‡
        const dis = dir.clone().multiplyScalar(moveSpeed);
        // ç›¸æœºæ²¿ç€è§†çº¿æ–¹å‘å¹³ç§»
        camera.position.add(dis);BoxFollow();

if (!duckBody) return;
console.log("æˆåŠŸ");

// å°†è§†çº¿æ–¹å‘è½¬æ¢ä¸º Ammo.js çš„å‘é‡
const force = new Ammo.btVector3(dir.x, dir.y, dir.z);

// ç¡®å®šåŠ›çš„å¤§å°
const forceMagnitude = 200; // å¯ä»¥æ ¹æ®éœ€è¦è°ƒæ•´åŠ›çš„å¤§å°

// å°†åŠ›ä¹˜ä»¥åŠ›çš„å¤§å°
force.op_mul(forceMagnitude);

// åœ¨åˆšä½“ä¸Šæ–½åŠ åŠ›
duckBody.applyCentralForce(force);

// é‡Šæ”¾åŠ›å‘é‡
Ammo.destroy(force);



}, 10);
                }  
                  
                function startMovingBackward() {  
if (moveBackwardInterval) {clearInterval(moveBackwardInterval);}
                    moveBackwardInterval = setInterval(function(){const dir = new THREE.Vector3();
        // è·å–ç›¸æœºçš„è§†çº¿æ–¹å‘
        camera.getWorldDirection(dir);
        const dis = dir.clone().multiplyScalar(-moveSpeed);  
        camera.position.add(dis);BoxFollow(); }, 10);  
                }  
                
        // è®¡ç®—å·¦å‘é‡ï¼Œä¸è§†çº¿æ–¹å‘å‚ç›´  
        function computeLeftVector(forward, up) {  
            const left = new THREE.Vector3();  
            left.crossVectors(up, forward).normalize();  
            return left;  
        }  
          
                function startMovingLeft() {  
if (moveLeftInterval) {clearInterval(moveLeftInterval);}
                  const dir = new THREE.Vector3();  
        camera.getWorldDirection(dir);  
        const left = computeLeftVector(dir, up);  
                    moveLeftInterval = setInterval(function(){const dis = left.clone().multiplyScalar(moveSpeed);  
            camera.position.add(dis);BoxFollow();}, 10);  
                }  
                  
        const up = new THREE.Vector3(0, 1, 0);
                function startMovingRight() {  
if (moveRightInterval) {clearInterval(moveRightInterval);}
        const dir = new THREE.Vector3();  
        camera.getWorldDirection(dir);  
        const left = computeLeftVector(dir, up);  
                    moveRightInterval = setInterval(function(){const dis = left.clone().multiplyScalar(-moveSpeed);  
            camera.position.add(dis);BoxFollow();}  , 10);  
                }  
                  
                function startMovingDown() {  
if (moveDownInterval) {clearInterval(moveDownInterval);}
                    moveDownInterval = setInterval(function(){moveCamera(0, -moveSpeed, 0);BoxFollow();}, 10);  
                }  
        
                function startMovingUp() {  
if (moveUpInterval) {clearInterval(moveUpInterval);}
                    moveUpInterval = setInterval(function(){moveCamera(0, moveSpeed, 0);BoxFollow();}, 10);  
                }  
        
                function stopMovingForward() {
                    clearInterval(moveForwardInterval); console.log("qingchu");
                }  
        
                function stopMovingBackward() {
                    clearInterval(moveBackwardInterval);  
                }  
        
                function stopMovingLeft() {
                    clearInterval(moveLeftInterval);  
                }  
        
                function stopMovingRight() {
                    clearInterval(moveRightInterval);  
                }  
        
                function stopMovingDown() {
                    clearInterval(moveDownInterval);  
                }  
        
                function stopMovingUp() {
                    clearInterval(moveUpInterval);  
                }  
                
    </script>
</body>

</html>